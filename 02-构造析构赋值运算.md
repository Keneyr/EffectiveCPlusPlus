## Constructor, Destructors, and Assignment Operators (构造、析构、赋值运算)

### 5. Know what functions C++ silently writes and calls. (了解C++默默编写并调用哪些函数)

编译器会为你的类做一些事情，当你写下`class Empty{};`的时候，相当于你写下了如下代码
```c++
class Empty{
public:
    Empty(){...}    //default构造函数
    Empty(const Empty& rhs){...}    //copy构造函数
    ~Empty(){...}   //析构函数
    Empty& operator=(const Empty& rhs){...} //copy assignment操作符
}
```
但是如果你自己写了class的构造函数，编译器就不会再为此类创建default构造函数

```c++
template<typename T>
class NamedObject{
public:
    NamedObject(const char* name, const T& value);
    NamedObject(const std::string& name, const T& value);
private:
    std::string nameValue;
    T objectValue;
}

NamedObject<int> no1("Smallest Prime Number", 2);
NamedObject<int> no2(no1);
```

上述代码中，有一件事情需要再加强记忆：

>编译器生成的copy构造函数必须以`no1.nameValue`和`no1.objectValue`为初值设定`no2.nameValue`和`no2.objectValue`。两者之中，nameValue的类型是string，而标准`string有个copy构造函数`，所以`no2.nameValue的初始化方式是调用string的copy构造函数并以no1.nameValue为实参`。另一个成员NamedObject<int>::objectValue的类型是int，那是个`内置类型`，所以no2.objectValue会以“拷贝no1.objectValue内的每一个bit”来完成初始化。

```c++
template<class T>
class NamedObject{
public:
    NameObject(std::string& name, const T& value);
private:
    std::string& nameValue;
    const T objectValue;
};

std::string newDog("Persephone");
std::string oldDog("Satch");
NamedObject<int> p(newDog, 2);
NamedObject<int> s(oldDog, 36);

p = s; //C++拒绝编译此行代码
```

上述代码中，如果你打算在一个“内涵reference成员”的class内支持赋值操作，你必须自己定义copy assignment操作符。面对“内含const成员”的classes，编译器的反应也是如此。

### 6. Explicitly disallow the use of compiler-generated functions you do not want. (若不想使用编译器自动生成的函数，就该明确拒绝)

如何阻止编译器帮我们自动创建copy构造函数，并且不允许此类的拷贝构造？
- 将自定义copy构造函数声明为`private`,但是这种不绝对安全，因为member函数和friend函数还是可以调用此private函数，所以需要第二点注意事项。
- 不去定义这个copy构造函数，这样如果某些人不慎调用任何一个，会获得连接错误(linkage error)。

```c++
class HomeForSale{
private:
    HomeForSale(const HomeForSale&);
    HomeForSale& operator=(const HomeForSale&);
}
```
- 但是更优的方式是，把连接期的错误转移至编译器，需要一个专门为了阻止copying动作而设计的base class。

```c++
class Uncopyable{
protected:
    Uncopyable(){}
    ~Uncopyable(){}
private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
}
class HomeForSale: private Uncopyable{

}
```
这时，只要任何`member函数或者friend函数`尝试拷贝HomeForSale对象，编译器便试着生成一个copy构造函数和一个copy assignment操作符，`这些函数会尝试调用其base class的对应函数`，那些调用会被编译器拒绝，因为base class的拷贝函数是private。

### 7. Declare destructors virtual in polymorphic base classes. (为多态基类声明virtual析构函数)

```c++
class TimeKeeper{
public:
    TimeKeeper();
    virtual ~TimeKeeper();
};
TimeKeeper* ptk = getTimeKeeper();
delete ptk;
```


### 8. Prevent exceptions from leaving destructors. (别让异常逃离析构函数)


### 9. Never call virtual functions during construction or destruction. (绝不在构造和析构过程中调用virtual函数)


### 10. Have assignment operators return a reference to *this. (令operator= 返回一个 reference to *this)


### 11. Handle assignment to self in operator=. (在operator=中处理“自我赋值”)


### 12. Copy all parts of an object. (复制对象时勿忘其每一个成分)